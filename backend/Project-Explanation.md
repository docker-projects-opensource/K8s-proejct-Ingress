# Backend Service

## What is this?

The Backend service is the "brain" of our application. It:
- Receives requests from the Frontend
- Processes those requests (like fetching or storing messages)
- Communicates with the Database to store or retrieve data
- Sends results back to the Frontend

You can think of it as a waiter in a restaurant - it takes your order (request), brings it to the kitchen (database), and returns with your food (data).

## Technologies Used

This service uses:
- **Node.js**: A JavaScript runtime for building server applications
- **Express**: A web framework for Node.js that simplifies creating web APIs
- **PostgreSQL Client**: A library that allows communication with the PostgreSQL database

## How It Works

1. The Express server listens for HTTP requests on port 3000
2. When a request comes in (like "get all messages" or "add a new message"), it routes to the right handler
3. The handler communicates with the PostgreSQL database to fetch or store data
4. The server formats the results and sends them back as JSON
5. For each request, it also logs activity to files in a logs directory

## API Endpoints

The Backend provides these main endpoints:
- `GET /api/messages`: Retrieves all messages from the database
- `POST /api/messages`: Adds a new message to the database
- `GET /health`: A simple health check endpoint that returns "OK"

## Docker Implementation

This service runs inside a Docker container. Here's what that means:

- **Docker Image**: We build a custom image based on Node.js Alpine
- **Multi-stage Build**: The Dockerfile uses a two-stage process:
  - First stage installs all dependencies and prepares the application
  - Second stage includes only production dependencies for a smaller final image
- **User Permissions**: The container runs as a non-root user (node) for better security
- **Networking**: 
  - Connects to the Frontend via `frontend-network`
  - Connects to the Database via `backend-network`
- **Volume**: Uses a persistent volume for logs so they aren't lost when the container restarts
- **Environment Variables**: Uses variables for configuration rather than hardcoded values

## Key Files

- `Dockerfile`: Instructions for building the Docker image
- `server.js`: The main application code that handles API requests
- `package.json`: Defines the Node.js project and its dependencies

## Docker Concepts Demonstrated

- **Multi-stage Builds**: Creating optimized Docker images
- **Docker Networks**: How containers communicate across isolated networks
- **Docker Volumes**: How to persist data across container restarts
- **Environment Variables**: Configuring containers externally without code changes
- **User Permissions**: Running containers as non-root users for security
- **Container Orchestration**: Working with multiple connected containers

## How to Interact With This Service

The Backend service isn't typically accessed directly by users. Instead:
- The Frontend service sends API requests to the Backend
- You can view the logs generated by the Backend in the `backend-logs` volume
- For debugging, you can directly access the API at http://localhost:3000/api/messages

## Relationship to Other Services

The Backend service:
- Receives requests from the Frontend service
- Sends queries to the Database service
- Acts as the middle layer that connects the user interface to the data storage

## Understanding the Dockerfile

```dockerfile
# Stage 1: Build stage
FROM node:16-alpine as build

WORKDIR /app

COPY package*.json ./
RUN npm install
COPY . .

# Stage 2: Production stage
FROM node:16-alpine

WORKDIR /app

RUN mkdir -p /app/logs && chown -R node:node /app

USER node

COPY --chown=node:node package*.json ./
RUN npm install --omit=dev

COPY --chown=node:node --from=build /app ./

EXPOSE 3000

CMD ["node", "server.js"]
```

This Dockerfile demonstrates:

1. **Multi-stage build**: We use a build stage to prepare everything, then only copy what we need to the final image
2. **Security best practices**: 
   - Using a non-root user (node)
   - Setting proper file permissions
   - Installing only production dependencies
3. **Working directory**: Setting up a proper directory structure
4. **Startup command**: Defining how the container should run
